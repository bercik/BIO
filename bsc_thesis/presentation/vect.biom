def create_vect(x=0.0, y=0.0)
   AS_LOC(v.x, x, v.y, y)
   RET(v)
end

@ zwraca dystans pomiędzy dwoma wektorami
def dist_vect(vec1, vec2)
   RET
   (
      SQRT ( { (vec1.x - vec2.x)^2 + (vec1.y - vec2.y)^2 } )
   )
end

@ zwraca nowy wektor będący wynikiem dodawania dwóch podanych wektorów
def add_vector(vec1, vec2)
   AS_LOC(new_vec.x, { vec1.x + vec2.x })
   AS_LOC(new_vec.y, { vec1.y + vec2.y })
   RET(new_vec)
end

@ zwraca nowy wektor będący wynikiem odejmowania dwóch podanych wektorów
def sub_vector(vec1, vec2)
   AS_LOC(new_vec.x, { vec1.x - vec2.x })
   AS_LOC(new_vec.y, { vec1.y - vec2.y })
   RET(new_vec)
end

@ wykonuje funkcję podaną jako parametr na dwóch wektorach
def perform_op(vec1, vec2, op)
   RET(CALL_BY_NAME(op, vec1, vec2))
end

@ funkcja dla FOREACH wykonująca operację na wszystkich wektorach i zwracająca nowy
@ lista operacji:
@ 1 - dodawanie
@ 2 - odejmowanie
def onEACH_vect_op(el, obj)
   @ inicjalizacja
   IF(NOT(HAS_FIELD(obj, new_vect)), AS_LOC(obj.new_vect, create_vect()))
   @ sprawdzenie jaką funkcję mamy wywołać
   IF({ obj.addPar == 1}, AS_LOC(op, "add_vector"), AS_LOC(op, "sub_vector")) 
   @ wywołanie funkcji
   AS_LOC(obj.new_vect, perform_op(obj.new_vect, el.val, op))
   @ zwrócenie nowego wektora
   RET(obj.new_vect)
end
