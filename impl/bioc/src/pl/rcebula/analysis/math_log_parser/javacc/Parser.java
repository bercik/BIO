/* Generated By:JJTree&JavaCC: Do not edit this line. Parser.java */
package pl.rcebula.analysis.math_log_parser.javacc;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.UnsupportedEncodingException;
import java.util.List;



public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants, ParserConstants {/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();

    public static List<pl.rcebula.analysis.lexer.Token<?>> process(pl.rcebula.analysis.lexer.Token<?> expression)
        throws ParseException, TokenMgrError, UnsupportedEncodingException
    {
        // SUB(ADD(SUB(1,2),3),4) O.K.
        //String input = "1 -2 + 3 - 4";

        // SUB(SUB(1, MUL(2, 3)), 4) O.K.
        //String input = "1 - 2 * 3 - 4";

        // SUB(ADD(MUL(1, 2), DIV(3, 4)), 5) O.K.
        //String input = "1 * 2 + 3 / 4 - 5";

        // MUL(2, SUB(SUB(3, 1), ADD(5, 2))) O.K.
        //String input = "2 * [3 - 1 - [5 + 2]]";

        // ADD(ADD(SUB(ADD(ADD(1, 2), 2), 4), DIV(ADD(10, DIV(MUL(5, 4), 2)), 5)), MUL(2, 2)) O.K.
        //String input = "1 + 2 % suma\n + 2 - 4 % różnica\n + (10 + 5 * 4 / 2) / 5 % iloraz\n + 2 * 2 % iloczyn\n";

        // ADD(MUL(3,4), MUL(2, SUB(4, DIV(10, 5)))) O.K.
        //String input = "3 * 4 + 2 * (4 - 10 / 5)";

        // SUB(MUL(NEGATE(NEGATE(3)), NEGATE(2)), NEGATE(ADD(10, 5)))
        //String input = "--3 * -2 - -(10 + 5)";

        // MUL(DIV(MUL(NEGATE(0), 0.0), 2.5), 0.3)
        //String input = "-0 * +0.0 / 2.5 * 0.3";

        // ADD(MUL(a, 2), DIV(MUL(DIV(NEGATE(3.5), d.z), true), def))
        //String input = "a * 2 + -3.5 / d.z * true / def";

        // MUL(2, ADD("abc	", "def"))
        //String input = "2 * (\"abc\t\" + \"def\")";

        // znaki specjalne (np. \n)
        //String input = " \"abc\" + \" \\\"def\\\" \" + \"hello\\nworld\" ";

        // litery UTF-8
        //String input = "\"żółć\" + \"ąśźßþœśð\"";

        String input = (String)expression.getValue();
        // TODELETE
        System.out.println(input);

        InputStream stream = new ByteArrayInputStream(input.getBytes("UTF-8"));

        Parser parser = new Parser(stream);
        SimpleNode root = parser.Start();

        // traverse(root, "");

        // TODELETE
        System.out.println();
        System.out.println(generateCode(root));

        return null;
    }

    private static String generateCode(SimpleNode node)
    {
        return generateCode(node, "");
    }

    private static String generateCode(SimpleNode node, String prevCode)
    {
        switch (node.toString())
        {
            case "START":
                SimpleNode P = (SimpleNode)node.jjtGetChild(0);
                SimpleNode T = (SimpleNode)node.jjtGetChild(1);
                SimpleNode E = (SimpleNode)node.jjtGetChild(2);

                prevCode = generateCode(P, prevCode);
                prevCode = generateCode(T, prevCode);
                prevCode = generateCode(E, prevCode);

                return prevCode;
            case "EXPR":
                if (node.value != null)
                {
                    String funName = "";
                    if (node.value.equals("+"))
                    {
                        funName = "ADD";
                    }
                    else if (node.value.equals("-"))
                    {
                        funName = "SUB";
                    }

                    P = (SimpleNode)node.jjtGetChild(0);
                    T = (SimpleNode)node.jjtGetChild(1);
                    E = (SimpleNode)node.jjtGetChild(2);

                    if (T.value != null)
                    {
                        String pGen = generateCode(P, "");
                        prevCode = funName + "(" + prevCode + ", " + generateCode(T, pGen) + ")";
                        prevCode = generateCode(E, prevCode);
                    }
                    else
                    {
                        prevCode = funName + "(" + prevCode + ", " + generateCode(P, "") + ")";
                        prevCode = generateCode(E, prevCode);
                    }

                    return prevCode;
                }
                else
                {
                    return prevCode;
                }
            case "TERM":
                if (node.value != null)
                {
                    String funName = "";
                    if (node.value.equals("*"))
                    {
                        funName = "MUL";
                    }
                    else if (node.value.equals("/"))
                    {
                        funName = "DIV";
                    }

                    P = (SimpleNode)node.jjtGetChild(0);
                    T = (SimpleNode)node.jjtGetChild(1);

                    prevCode = funName + "(" + prevCode + ", " + generateCode(P, "") + ")";
                    prevCode = generateCode(T, prevCode);

                    return prevCode;
                }
                else
                {
                    return prevCode;
                }
            case "PRIM":
                // wartość liczbowa, plus lub minus
                if (node.value != null)
                {
                    if (node.value.equals("+"))
                    {
                        P = (SimpleNode)node.jjtGetChild(0);
                        return generateCode(P, "");
                    }
                    else if (node.value.equals("-"))
                    {
                        P = (SimpleNode)node.jjtGetChild(0);
                        return "NEGATE(" + generateCode(P, "") + ")";
                    }
                    else
                    {
                        return prevCode + node.value.toString();
                    }
                }
                // nawiasy
                else
                {
                    SimpleNode S = (SimpleNode)node.jjtGetChild(0);
                    return generateCode(S, "");
                }
            default:
                throw new RuntimeException("unknown node type: " + node.toString());
        }
    }

    private static void traverse(SimpleNode node, String prefix)
    {
        if (node.jjtGetValue() != null)
        {
            System.out.println(node.toString(prefix) + ": " + node.jjtGetValue());
        }
        else
        {
            System.out.println(node.toString(prefix));
        }

        for (int i = 0; i < node.jjtGetNumChildren(); ++i)
        {
            SimpleNode n = (SimpleNode)node.jjtGetChild(i);
            traverse(n, prefix + "-");
        }
    }

  final public SimpleNode Start() throws ParseException {
 /*@bgen(jjtree) START */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Primary();
      Term();
      Expression();
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public void Expression() throws ParseException {
 /*@bgen(jjtree) EXPR */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          jj_consume_token(PLUS);
          Primary();
          Term();
          Expression();
          jjtn000.value = "+";
          break;
        case MINUS:
          jj_consume_token(MINUS);
          Primary();
          Term();
          Expression();
          jjtn000.value = "-";
          break;
        default:
          jj_la1[0] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[1] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void Term() throws ParseException {
 /*@bgen(jjtree) TERM */
  SimpleNode jjtn000 = new SimpleNode(JJTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TIMES:
      case DIVIDE:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TIMES:
          jj_consume_token(TIMES);
          Primary();
          Term();
          jjtn000.value = "*";
          break;
        case DIVIDE:
          jj_consume_token(DIVIDE);
          Primary();
          Term();
          jjtn000.value = "/";
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void Primary() throws ParseException {
 /*@bgen(jjtree) PRIM */
    SimpleNode jjtn000 = new SimpleNode(JJTPRIM);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT:
        t = jj_consume_token(INT);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.value = t.image;
        break;
      case FLOAT:
        t = jj_consume_token(FLOAT);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.value = t.image;
        break;
      case ID:
        t = jj_consume_token(ID);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.value = t.image;
        break;
      case KEYWORDS:
        t = jj_consume_token(KEYWORDS);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.value = t.image;
        break;
      case STRING:
        t = jj_consume_token(STRING);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.value = t.image;
        break;
      case PLUS:
        jj_consume_token(PLUS);
        Primary();
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.value = "+";
        break;
      case MINUS:
        jj_consume_token(MINUS);
        Primary();
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.value = "-";
        break;
      case OPEN_PAR:
        jj_consume_token(OPEN_PAR);
        Start();
        jj_consume_token(CLOSE_PAR);
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  /** Generated Token Manager. */
  public ParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[5];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x60,0x60,0x180,0x180,0x223a60,};
   }

  /** Constructor with InputStream. */
  public Parser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Parser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Parser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[22];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 5; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 22; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
