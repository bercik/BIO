/* Generated By:JJTree&JavaCC: Do not edit this line. Parser.java */
package pl.rcebula.analysis.math_log_parser.javacc;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.UnsupportedEncodingException;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;

import pl.rcebula.error_report.ErrorInfo;
import pl.rcebula.analysis.lexer.TokenType;
import pl.rcebula.error_report.MyFiles;
import pl.rcebula.utils.StringUtils;
import pl.rcebula.analysis.lexer.LexerError;
import pl.rcebula.analysis.parser.ParserError;
import pl.rcebula.analysis.math_log_parser.MyNumberFormatException;

import java.lang.RuntimeException;


public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants, ParserConstants {/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();private static ErrorInfo ei;
    private static ErrorInfo defaultErrorInfo;

    // często używane tokeny
    private static pl.rcebula.analysis.lexer.Token getCommaToken()
    {
        return new pl.rcebula.analysis.lexer.Token(TokenType.COMMA, null, defaultErrorInfo);
    }

    private static pl.rcebula.analysis.lexer.Token getOpenParToken()
    {
        return new pl.rcebula.analysis.lexer.Token(TokenType.OPEN_BRACKET, null, defaultErrorInfo);
    }

    private static pl.rcebula.analysis.lexer.Token getCloseParToken()
    {
        return new pl.rcebula.analysis.lexer.Token(TokenType.CLOSE_BRACKET, null, defaultErrorInfo);
    }

    private static pl.rcebula.analysis.lexer.Token getFunToken(String funName, ErrorInfo ei)
    {
        return new pl.rcebula.analysis.lexer.Token(TokenType.ID, funName, ei);
    }

    public static List<pl.rcebula.analysis.lexer.Token<?>> process(pl.rcebula.analysis.lexer.Token<?> expression,
        MyFiles files)
            throws ParserError, LexerError, UnsupportedEncodingException
    {
        defaultErrorInfo = new ErrorInfo(-1, -1, files.getFileGeneratedByCompiler());

        ei = expression.getErrorInfo();
        String input = (String)expression.getValue();

        // TODELETE
        //System.out.println("\nMATH_LOG_PARSER:");
        //System.out.println(input);

        InputStream stream = new ByteArrayInputStream(input.getBytes("UTF-8"));

        Parser parser = new Parser(stream);
        SimpleNode root = null;
        try
        {
            root = parser.Start();
        }
        catch (TokenMgrError err)
        {
            int lineNum = err.errorLine;
            int chNum = err.errorColumn;
            String msg = "Unexpected character \u005c"" + err.curChar + "\u005c" in token \u005c"" +
                err.errorAfter + "\u005c"";

            throw new LexerError(generateErrorInfo(lineNum, chNum), msg);
        }
        catch (ParseException err)
        {
            String msg = "Expected: (";
            for (String s : err.expectedTokens)
            {
                msg += s + ", ";
            }
            msg = msg.substring(0, msg.length() - 2);
            msg += ") got " + err.currentTokenName;

            int lineNum = err.currentToken.next.beginLine;
            int chNum = err.currentToken.next.beginColumn;

            throw new ParserError(generateErrorInfo(lineNum, chNum), msg);
        }
        catch (MyNumberFormatException err)
        {
            Token t = err.getToken();
            int lineNum = t.beginLine;
            int chNum = t.beginColumn;

            String msg = "Integer constant " + t.image + " is too large or too small";

            throw new LexerError(generateErrorInfo(lineNum, chNum), msg);
        }

        // TODELETE
        //System.out.println(input);
        //traverse(root, "");
        //System.out.println("----------------\n");

        List<pl.rcebula.analysis.lexer.Token<?>> tokens = generateCode(root);
        // TODELETE
        //printTokens(tokens);

        return tokens;
    }

    private static ErrorInfo generateErrorInfo(int lineNum, int chNum)
    {
        lineNum = lineNum + ei.getLineNum() - 1;
        chNum = chNum + ei.getChNum() - 1;

        return new ErrorInfo(lineNum, chNum, ei.getFile());
    }

    private String parseString(String str, int line, int chNum)
            throws LexerError
    {
        // usuwamy początkowy i końcowy cudzysłów
        str = str.substring(1, str.length() - 1);

        String newStr = "";

        // przechodzimy po całym napisie i szukamy znaków specjalnych
        boolean specChar = false;
        for (int i = 0; i < str.length(); ++i)
        {
            Character ch = str.charAt(i);

            if (specChar)
            {
                if (!StringUtils.specialCharacters.containsKey(ch))
                {
                    throw new LexerError(generateErrorInfo(line, chNum),
                            "Illegal special character \u005c\u005c" + ch
                            + " in string \u005c"" + str + "\u005c"");
                }

                newStr += StringUtils.specialCharacters.get(ch);
                specChar = false;
            }
            else if (ch.equals('\u005c\u005c'))
            {
                specChar = true;
            }
            else
            {
                newStr += ch;
            }
        }

        if (specChar)
        {
            throw new LexerError(generateErrorInfo(line, chNum),
                    "Not completed special character in string \u005c""
                    + str + "\u005c"");
        }

        return newStr;
    }

    private static void printTokens(List<pl.rcebula.analysis.lexer.Token<?>> tokens)
    {
        for (pl.rcebula.analysis.lexer.Token<?> t : tokens)
        {
            System.out.println(t);
        }
    }

    private static boolean isParentFunCall(SimpleNode node)
    {
        return (node.jjtGetParent().toString().equals("FUN_CALL"));
    }

    private static List<pl.rcebula.analysis.lexer.Token<?>> generateCode(SimpleNode node)
    throws ParserError
    {
        return generateCode(node, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>(), false);
    }

    private static List<pl.rcebula.analysis.lexer.Token<?>> generateCode(SimpleNode node,
        List<pl.rcebula.analysis.lexer.Token<?>> prevTokens, boolean insideFunCall)
    throws ParserError
    {
        if (node.jjtGetNumChildren() == 0)
        {
            // jeżeli nie null to znaczy, że node jest typu PRIM
                        // ale nie jest FUN_CALL
            if (node.value != null)
            {
                return Arrays.asList((pl.rcebula.analysis.lexer.Token)node.value);
            }
            else
            {
                return prevTokens;
            }
        }
        else if (node.jjtGetNumChildren() == 1)
        {
            SimpleNode center = (SimpleNode)node.jjtGetChild(0);

            // FUN_CALL
            if (node.toString().equals("PRIM") && node.value != null)
            {
                // child jest typu FUN_CALL
                List<pl.rcebula.analysis.lexer.Token<?>> newTokens =
                        new ArrayList<pl.rcebula.analysis.lexer.Token<?>>();

                newTokens.add((pl.rcebula.analysis.lexer.Token)node.value);
                newTokens.add(getOpenParToken());
                newTokens.addAll(generateCode(center, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>(), insideFunCall));
                newTokens.add(getCloseParToken());

                return newTokens;
            }
            // COMMA
            else if (node.toString().equals("COMMA_EXPR"))
            {
                // sprawdź czy wewnątrz fun_call, jeżeli nie to wyrzuć wyjątek
                if (!insideFunCall)
                {
                    String msg = "You can't use comma outside function call";
                    ErrorInfo ei = ((ValueErrorInfo)node.value).errorInfo;
                    throw new ParserError(ei, msg);
                }

                // child jest typu EXPR
                List<pl.rcebula.analysis.lexer.Token<?>> newTokens =
                        new ArrayList<pl.rcebula.analysis.lexer.Token<?>>();

                newTokens.add(getCommaToken());
                newTokens.addAll(generateCode(center, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>(), insideFunCall));

                return newTokens;
            }
            else if (node.toString().equals("EXPR"))
            {
                // sprawdź czy to od fun_call
                insideFunCall = isParentFunCall(node);
            }

            // expr bez comma_expr, fun_call nawiasy, primary nawiasy, neg_ex nic, not_ex nic, indx_ex nic
            if (node.value == null)
            {
                return generateCode(center, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>(), insideFunCall);
            }
            // neg_ex znak minus
            else if (node.value.equals("-"))
            {
                ValueErrorInfo vei = (ValueErrorInfo)node.value;
                pl.rcebula.analysis.lexer.Token funTok = getFunToken("NEGATE", vei.errorInfo);

                List<pl.rcebula.analysis.lexer.Token<?>> newTokens =
                        new ArrayList<pl.rcebula.analysis.lexer.Token<?>>();

                newTokens.add(funTok);
                newTokens.add(getOpenParToken());
                newTokens.addAll(generateCode(center, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>(), insideFunCall));
                newTokens.add(getCloseParToken());

                return newTokens;
            }
            // not_ex znak wykrzyknika
            else if (node.value.equals("!"))
            {
                ValueErrorInfo vei = (ValueErrorInfo)node.value;
                pl.rcebula.analysis.lexer.Token funTok = getFunToken("NOT", vei.errorInfo);

                List<pl.rcebula.analysis.lexer.Token<?>> newTokens =
                        new ArrayList<pl.rcebula.analysis.lexer.Token<?>>();

                newTokens.add(funTok);
                newTokens.add(getOpenParToken());
                newTokens.addAll(generateCode(center, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>(), insideFunCall));
                newTokens.add(getCloseParToken());

                return newTokens;
            }
            // neg_ex znak plus
            else if (node.value.equals("+"))
            {
                return generateCode(center, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>(), insideFunCall);
            }
            // pow_ex potęga
            else if (node.value.equals("^"))
            {
                ValueErrorInfo vei = (ValueErrorInfo)node.value;
                pl.rcebula.analysis.lexer.Token funTok = getFunToken("POW", vei.errorInfo);

                List<pl.rcebula.analysis.lexer.Token<?>> newTokens =
                        new ArrayList<pl.rcebula.analysis.lexer.Token<?>>();

                newTokens.add(funTok);
                newTokens.add(getOpenParToken());
                newTokens.addAll(prevTokens);
                newTokens.add(getCommaToken());
                newTokens.addAll(generateCode(center, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>(), insideFunCall));
                newTokens.add(getCloseParToken());

                return newTokens;
            }
            // nieobsługiwany znak
            else
            {
                throw new RuntimeException("Can't handle " + node.toString());
            }
        }
        else if (node.jjtGetNumChildren() == 2)
        {
            SimpleNode left = (SimpleNode)node.jjtGetChild(0);
            SimpleNode right = (SimpleNode)node.jjtGetChild(1);

            // EXPR, dziećmi są OR_EX i COMMA_EXPR
            if (node.toString().equals("EXPR"))
            {
                // sprawdź czy to od fun_call
                insideFunCall = isParentFunCall(node);

                List<pl.rcebula.analysis.lexer.Token<?>> newTokens =
                        new ArrayList<pl.rcebula.analysis.lexer.Token<?>>();

                newTokens.addAll(generateCode(left, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>(), insideFunCall));
                newTokens.addAll(generateCode(right, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>(), insideFunCall));

                return newTokens;
            }

            // jeżeli nie ma wartości
            if (node.value == null)
            {
                return generateCode(right, generateCode(left, prevTokens, insideFunCall), insideFunCall);
            }
            else
            {
                pl.rcebula.analysis.lexer.Token funTok = null;
                // inaczej typu ValueErrorInfo, możemy użyć metody equals(Object obj)
                if (node.value.equals("+"))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("ADD", vei.errorInfo);
                }
                else if (node.value.equals("-"))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("SUB", vei.errorInfo);
                }
                else if (node.value.equals("*"))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("MUL", vei.errorInfo);
                }
                else if (node.value.equals("/"))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("DIV", vei.errorInfo);
                }
                else if (node.value.equals("%"))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("MOD", vei.errorInfo);
                }
                else if (node.value.equals("||"))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("OR", vei.errorInfo);
                }
                else if (node.value.equals("&&"))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("AND", vei.errorInfo);
                }
                else if (node.value.equals("=="))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("EQ", vei.errorInfo);
                }
                else if (node.value.equals("!="))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("NEQ", vei.errorInfo);
                }
                else if (node.value.equals(">"))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("GT", vei.errorInfo);
                }
                else if (node.value.equals(">="))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("GE", vei.errorInfo);
                }
                else if (node.value.equals("<"))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("LS", vei.errorInfo);
                }
                else if (node.value.equals("<="))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("LE", vei.errorInfo);
                }
                else if (node.value.equals("[]"))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("GET", vei.errorInfo);
                }
                else
                {
                    throw new RuntimeException("Uknown node value: " + node.value.toString());
                }

                List<pl.rcebula.analysis.lexer.Token<?>> newTokens =
                        new ArrayList<pl.rcebula.analysis.lexer.Token<?>>();

                newTokens.add(funTok);
                newTokens.add(getOpenParToken());
                newTokens.addAll(prevTokens);
                newTokens.add(getCommaToken());
                newTokens.addAll(generateCode(left, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>(), insideFunCall));
                newTokens.add(getCloseParToken());

                return generateCode(right, newTokens, insideFunCall);
            }
        }
        else
        {
            throw new RuntimeException("Can't handle " + node.jjtGetNumChildren()
                + " node childrens");
        }
    }

    private static void traverse(SimpleNode node, String prefix)
    {
        if (node.jjtGetValue() != null)
        {
            System.out.println(node.toString(prefix) + ": " + node.jjtGetValue());
        }
        else
        {
            System.out.println(node.toString(prefix));
        }

        for (int i = 0; i < node.jjtGetNumChildren(); ++i)
        {
            SimpleNode n = (SimpleNode)node.jjtGetChild(i);
            traverse(n, prefix + "-");
        }
    }

  final public SimpleNode Start() throws ParseException {
 /*@bgen(jjtree) START */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expression();
      jj_consume_token(0);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public void Expression() throws ParseException {
 /*@bgen(jjtree) EXPR */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      or_ex();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        comma_expr();
        break;
      default:
        jj_la1[0] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void comma_expr() throws ParseException {
 /*@bgen(jjtree) COMMA_EXPR */
    SimpleNode jjtn000 = new SimpleNode(JJTCOMMA_EXPR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(COMMA);
      Expression();
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        int newLine = t.beginLine + ei.getLineNum() - 1;
        int newCh;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        jjtn000.value = new ValueErrorInfo(",", new ErrorInfo(newLine, newCh, ei.getFile()));
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void or_ex() throws ParseException {
 /*@bgen(jjtree) OR_EX */
  SimpleNode jjtn000 = new SimpleNode(JJTOR_EX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      and_ex();
      or_ex_1();
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void or_ex_1() throws ParseException {
 /*@bgen(jjtree) OR_EX_1 */
    SimpleNode jjtn000 = new SimpleNode(JJTOR_EX_1);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        t = jj_consume_token(OR);
        and_ex();
        or_ex_1();
            int newLine = t.beginLine + ei.getLineNum() - 1;
            int newCh;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("||", new ErrorInfo(newLine, newCh, ei.getFile()));
        break;
      default:
        jj_la1[1] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void and_ex() throws ParseException {
 /*@bgen(jjtree) AND_EX */
  SimpleNode jjtn000 = new SimpleNode(JJTAND_EX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      eq_ex();
      and_ex_1();
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void and_ex_1() throws ParseException {
 /*@bgen(jjtree) AND_EX_1 */
    SimpleNode jjtn000 = new SimpleNode(JJTAND_EX_1);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        t = jj_consume_token(AND);
        eq_ex();
        and_ex_1();
            int newLine = t.beginLine + ei.getLineNum() - 1;
            int newCh;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("&&", new ErrorInfo(newLine, newCh, ei.getFile()));
        break;
      default:
        jj_la1[2] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void eq_ex() throws ParseException {
 /*@bgen(jjtree) EQ_EX */
  SimpleNode jjtn000 = new SimpleNode(JJTEQ_EX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      cmp_ex();
      eq_ex_1();
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void eq_ex_1() throws ParseException {
 /*@bgen(jjtree) EQ_EX_1 */
    SimpleNode jjtn000 = new SimpleNode(JJTEQ_EX_1);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
      case NEQ:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQ:
          t = jj_consume_token(EQ);
          cmp_ex();
          eq_ex_1();
            int newLine = t.beginLine + ei.getLineNum() - 1;
            int newCh;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("==", new ErrorInfo(newLine, newCh, ei.getFile()));
          break;
        case NEQ:
          t = jj_consume_token(NEQ);
          cmp_ex();
          eq_ex_1();
            newLine = t.beginLine + ei.getLineNum() - 1;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("!=", new ErrorInfo(newLine, newCh, ei.getFile()));
          break;
        default:
          jj_la1[3] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void cmp_ex() throws ParseException {
 /*@bgen(jjtree) CMP_EX */
  SimpleNode jjtn000 = new SimpleNode(JJTCMP_EX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      add_ex();
      cmp_ex_1();
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void cmp_ex_1() throws ParseException {
 /*@bgen(jjtree) CMP_EX_1 */
    SimpleNode jjtn000 = new SimpleNode(JJTCMP_EX_1);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LS:
      case LE:
      case GT:
      case GE:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LS:
          t = jj_consume_token(LS);
          add_ex();
          cmp_ex_1();
            int newLine = t.beginLine + ei.getLineNum() - 1;
            int newCh;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("<", new ErrorInfo(newLine, newCh, ei.getFile()));
          break;
        case LE:
          t = jj_consume_token(LE);
          add_ex();
          cmp_ex_1();
            newLine = t.beginLine + ei.getLineNum() - 1;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("<=", new ErrorInfo(newLine, newCh, ei.getFile()));
          break;
        case GT:
          t = jj_consume_token(GT);
          add_ex();
          cmp_ex_1();
            newLine = t.beginLine + ei.getLineNum() - 1;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo(">", new ErrorInfo(newLine, newCh, ei.getFile()));
          break;
        case GE:
          t = jj_consume_token(GE);
          add_ex();
          cmp_ex_1();
            newLine = t.beginLine + ei.getLineNum() - 1;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo(">=", new ErrorInfo(newLine, newCh, ei.getFile()));
          break;
        default:
          jj_la1[5] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[6] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void add_ex() throws ParseException {
 /*@bgen(jjtree) ADD_EX */
  SimpleNode jjtn000 = new SimpleNode(JJTADD_EX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      mul_ex();
      add_ex_1();
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void add_ex_1() throws ParseException {
 /*@bgen(jjtree) ADD_EX_1 */
    SimpleNode jjtn000 = new SimpleNode(JJTADD_EX_1);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          t = jj_consume_token(PLUS);
          mul_ex();
          add_ex_1();
            int newLine = t.beginLine + ei.getLineNum() - 1;
            int newCh;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("+", new ErrorInfo(newLine, newCh, ei.getFile()));
          break;
        case MINUS:
          t = jj_consume_token(MINUS);
          mul_ex();
          add_ex_1();
            newLine = t.beginLine + ei.getLineNum() - 1;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("-", new ErrorInfo(newLine, newCh, ei.getFile()));
          break;
        default:
          jj_la1[7] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void mul_ex() throws ParseException {
 /*@bgen(jjtree) MUL_EX */
  SimpleNode jjtn000 = new SimpleNode(JJTMUL_EX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      pow_ex();
      mul_ex_1();
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void mul_ex_1() throws ParseException {
 /*@bgen(jjtree) MUL_EX_1 */
    SimpleNode jjtn000 = new SimpleNode(JJTMUL_EX_1);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TIMES:
      case DIVIDE:
      case MODULO:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TIMES:
          t = jj_consume_token(TIMES);
          pow_ex();
          mul_ex_1();
            int newLine = t.beginLine + ei.getLineNum() - 1;
            int newCh;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("*", new ErrorInfo(newLine, newCh, ei.getFile()));
          break;
        case DIVIDE:
          t = jj_consume_token(DIVIDE);
          pow_ex();
          mul_ex_1();
            newLine = t.beginLine + ei.getLineNum() - 1;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("/", new ErrorInfo(newLine, newCh, ei.getFile()));
          break;
        case MODULO:
          t = jj_consume_token(MODULO);
          pow_ex();
          mul_ex_1();
            newLine = t.beginLine + ei.getLineNum() - 1;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("%", new ErrorInfo(newLine, newCh, ei.getFile()));
          break;
        default:
          jj_la1[9] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[10] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void pow_ex() throws ParseException {
 /*@bgen(jjtree) POW_EX */
  SimpleNode jjtn000 = new SimpleNode(JJTPOW_EX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      neg_ex();
      pow_ex_1();
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void pow_ex_1() throws ParseException {
 /*@bgen(jjtree) POW_EX_1 */
    SimpleNode jjtn000 = new SimpleNode(JJTPOW_EX_1);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case POWER:
        t = jj_consume_token(POWER);
        pow_ex();
            int newLine = t.beginLine + ei.getLineNum() - 1;
            int newCh;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("^", new ErrorInfo(newLine, newCh, ei.getFile()));
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void neg_ex() throws ParseException {
 /*@bgen(jjtree) NEG_EX */
    SimpleNode jjtn000 = new SimpleNode(JJTNEG_EX);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
        t = jj_consume_token(MINUS);
        neg_ex();
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        int newLine = t.beginLine + ei.getLineNum() - 1;
        int newCh;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        jjtn000.value = new ValueErrorInfo("-", new ErrorInfo(newLine, newCh, ei.getFile()));
        break;
      case PLUS:
        t = jj_consume_token(PLUS);
        neg_ex();
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        newLine = t.beginLine + ei.getLineNum() - 1;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        jjtn000.value = new ValueErrorInfo("+", new ErrorInfo(newLine, newCh, ei.getFile()));
        break;
      case EXCL_MARK:
      case OPEN_PAR:
      case NONE:
      case TRUE:
      case FALSE:
      case INT:
      case FLOAT:
      case ID_STRUCT:
      case ID:
      case STRING:
        not_ex();
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void not_ex() throws ParseException {
 /*@bgen(jjtree) NEG_EX */
    SimpleNode jjtn000 = new SimpleNode(JJTNEG_EX);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXCL_MARK:
        t = jj_consume_token(EXCL_MARK);
        indx_ex();
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        int newLine = t.beginLine + ei.getLineNum() - 1;
        int newCh;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        jjtn000.value = new ValueErrorInfo("!", new ErrorInfo(newLine, newCh, ei.getFile()));
        break;
      case OPEN_PAR:
      case NONE:
      case TRUE:
      case FALSE:
      case INT:
      case FLOAT:
      case ID_STRUCT:
      case ID:
      case STRING:
        indx_ex();
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void indx_ex() throws ParseException {
 /*@bgen(jjtree) INDX_EX */
  SimpleNode jjtn000 = new SimpleNode(JJTINDX_EX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      primary();
      indx_ex_1();
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void indx_ex_1() throws ParseException {
 /*@bgen(jjtree) INDX_EX_1 */
    SimpleNode jjtn000 = new SimpleNode(JJTINDX_EX_1);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_INDX:
        t = jj_consume_token(OPEN_INDX);
        Expression();
        jj_consume_token(CLOSE_INDX);
        indx_ex_1();
            int newLine = t.beginLine + ei.getLineNum() - 1;
            int newCh;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("[]", new ErrorInfo(newLine, newCh, ei.getFile()));
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void primary() throws ParseException {
 /*@bgen(jjtree) PRIM */
    SimpleNode jjtn000 = new SimpleNode(JJTPRIM);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT:
        t = jj_consume_token(INT);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        int newLine = t.beginLine + ei.getLineNum() - 1;
        int newCh;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        try
        {
            jjtn000.value =
                new pl.rcebula.analysis.lexer.Token(TokenType.INT, Integer.parseInt(t.image),
                    new ErrorInfo(newLine, newCh, ei.getFile()));
        }
        catch (NumberFormatException ex)
        {
            {if (true) throw new MyNumberFormatException(t);}
        }
        break;
      case FLOAT:
        t = jj_consume_token(FLOAT);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        newLine = t.beginLine + ei.getLineNum() - 1;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        try
        {
            jjtn000.value =
                new pl.rcebula.analysis.lexer.Token(TokenType.FLOAT, Float.parseFloat(t.image),
                    new ErrorInfo(newLine, newCh, ei.getFile()));
        }
        catch (NumberFormatException ex)
        {
            {if (true) throw new MyNumberFormatException(t);}
        }
        break;
      case ID:
        t = jj_consume_token(ID);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_PAR:
          fun_call();
          break;
        default:
          jj_la1[15] = jj_gen;
          ;
        }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        newLine = t.beginLine + ei.getLineNum() - 1;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        jjtn000.value =
            new pl.rcebula.analysis.lexer.Token(TokenType.ID, t.image,
                new ErrorInfo(newLine, newCh, ei.getFile()));
        break;
      case ID_STRUCT:
        t = jj_consume_token(ID_STRUCT);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        newLine = t.beginLine + ei.getLineNum() - 1;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        jjtn000.value =
            new pl.rcebula.analysis.lexer.Token(TokenType.ID_STRUCT, t.image,
                new ErrorInfo(newLine, newCh, ei.getFile()));
        break;
      case TRUE:
        t = jj_consume_token(TRUE);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        newLine = t.beginLine + ei.getLineNum() - 1;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        jjtn000.value =
            new pl.rcebula.analysis.lexer.Token(TokenType.BOOL, true,
                new ErrorInfo(newLine, newCh, ei.getFile()));
        break;
      case FALSE:
        t = jj_consume_token(FALSE);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        newLine = t.beginLine + ei.getLineNum() - 1;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        jjtn000.value =
            new pl.rcebula.analysis.lexer.Token(TokenType.BOOL, false,
                new ErrorInfo(newLine, newCh, ei.getFile()));
        break;
      case NONE:
        t = jj_consume_token(NONE);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        newLine = t.beginLine + ei.getLineNum() - 1;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        jjtn000.value =
            new pl.rcebula.analysis.lexer.Token(TokenType.NONE, null,
                new ErrorInfo(newLine, newCh, ei.getFile()));
        break;
      case STRING:
        t = jj_consume_token(STRING);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        newLine = t.beginLine + ei.getLineNum() - 1;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        String str = parseString(t.image, t.beginLine, t.beginColumn);
        jjtn000.value =
            new pl.rcebula.analysis.lexer.Token<String>(TokenType.STRING, str,
                new ErrorInfo(newLine, newCh, ei.getFile()));
        break;
      case OPEN_PAR:
        jj_consume_token(OPEN_PAR);
        Expression();
        jj_consume_token(CLOSE_PAR);
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void fun_call() throws ParseException {
 /*@bgen(jjtree) FUN_CALL */
  SimpleNode jjtn000 = new SimpleNode(JJTFUN_CALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(OPEN_PAR);
      Expression();
      jj_consume_token(CLOSE_PAR);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  /** Generated Token Manager. */
  public ParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[17];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x100000,0x20,0x40,0x180,0x180,0x1e00,0x1e00,0x6000,0x6000,0x38000,0x38000,0x40000,0xf9086000,0xf9080000,0x400000,0x1000000,0xf9000000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x118,0x118,0x0,0x0,0x118,};
   }

  /** Constructor with InputStream. */
  public Parser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Parser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Parser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[41];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 17; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 41; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}

class ValueErrorInfo
{
    public ValueErrorInfo(String value, ErrorInfo errorInfo)
    {
        this.value = value;
        this.errorInfo = errorInfo;
    }

    public boolean equals(Object obj)
    {
        String s = (String)obj;
        return value.equals(s);
    }

    public String value;
    public ErrorInfo errorInfo;

    @Override
    public String toString()
    {
        return value;
    }
}
