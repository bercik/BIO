/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. parser.jj */
/*@egen*//* parser.jjt parsing expressions to BIO code */
options 
{
    STATIC = false;
    UNICODE_INPUT = true;
}
PARSER_BEGIN(Parser)

package pl.rcebula.analysis.math_log_parser.javacc;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.UnsupportedEncodingException;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;

import pl.rcebula.error_report.ErrorInfo;
import pl.rcebula.analysis.lexer.TokenType;
import pl.rcebula.error_report.MyFiles;
import pl.rcebula.utils.StringUtils;
import pl.rcebula.analysis.lexer.LexerError;
import pl.rcebula.analysis.parser.ParserError;
import pl.rcebula.analysis.math_log_parser.MyNumberFormatException;


public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/ 
{/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();

/*@egen*/
    private static ErrorInfo ei;
    private static ErrorInfo defaultErrorInfo;
    
    // cz\u0119sto u\u017cywane tokeny
    private static pl.rcebula.analysis.lexer.Token getCommaToken()
    {
        return new pl.rcebula.analysis.lexer.Token(TokenType.COMMA, null, defaultErrorInfo);
    }

    private static pl.rcebula.analysis.lexer.Token getOpenParToken()
    {
        return new pl.rcebula.analysis.lexer.Token(TokenType.OPEN_BRACKET, null, defaultErrorInfo);
    }

    private static pl.rcebula.analysis.lexer.Token getCloseParToken()
    {
        return new pl.rcebula.analysis.lexer.Token(TokenType.CLOSE_BRACKET, null, defaultErrorInfo);
    }

    private static pl.rcebula.analysis.lexer.Token getFunToken(String funName, ErrorInfo ei)
    {
        return new pl.rcebula.analysis.lexer.Token(TokenType.ID, funName, ei);
    }

    public static List<pl.rcebula.analysis.lexer.Token<?>> process(pl.rcebula.analysis.lexer.Token<?> expression,
        MyFiles files)
            throws ParserError, LexerError, UnsupportedEncodingException
    {
        defaultErrorInfo = new ErrorInfo(-1, -1, files.getFileGeneratedByCompiler());

        ei = expression.getErrorInfo();
        String input = (String)expression.getValue();

        // TODELETE
        //System.out.println("\nMATH_LOG_PARSER:");
        //System.out.println(input);

        InputStream stream = new ByteArrayInputStream(input.getBytes("UTF-8"));

        Parser parser = new Parser(stream);
        SimpleNode root = null;
        try
        {
            root = parser.Start();
        }
        catch (TokenMgrError err)
        {
            int lineNum = err.errorLine;
            int chNum = err.errorColumn;
            String msg = "Unexpected character \"" + err.curChar + "\" in token \"" + 
                err.errorAfter + "\"";

            throw new LexerError(generateErrorInfo(lineNum, chNum), msg);
        }
        catch (ParseException err)
        {
            String msg = "Expected: (";
            for (String s : err.expectedTokens)
            {   
                msg += s + ", ";
            }
            msg = msg.substring(0, msg.length() - 2);
            msg += ") got " + err.currentTokenName;

            int lineNum = err.currentToken.next.beginLine;
            int chNum = err.currentToken.next.beginColumn;

            throw new ParserError(generateErrorInfo(lineNum, chNum), msg);
        }
        catch (MyNumberFormatException err)
        {
            Token t = err.getToken();
            int lineNum = t.beginLine;
            int chNum = t.beginColumn;
            
            String msg = "Integer constant " + t.image + " is too large or too small";

            throw new LexerError(generateErrorInfo(lineNum, chNum), msg);
        }

        // TODELETE
        //System.out.println(input);
        //traverse(root, "");
        //System.out.println("----------------\n");

        List<pl.rcebula.analysis.lexer.Token<?>> tokens = generateCode(root);
        // TODELETE
        //printTokens(tokens);

        return tokens;
    }

    private static ErrorInfo generateErrorInfo(int lineNum, int chNum)
    {
        lineNum = lineNum + ei.getLineNum() - 1;
        chNum = chNum + ei.getChNum() - 1;
        
        return new ErrorInfo(lineNum, chNum, ei.getFile());
    }

    private String parseString(String str, int line, int chNum)
            throws LexerError
    {
        // usuwamy pocz\u0105tkowy i ko\u0144cowy cudzys\u0142\u00f3w
        str = str.substring(1, str.length() - 1);

        String newStr = "";

        // przechodzimy po ca\u0142ym napisie i szukamy znak\u00f3w specjalnych
        boolean specChar = false;
        for (int i = 0; i < str.length(); ++i)
        {
            Character ch = str.charAt(i);

            if (specChar)
            {
                if (!StringUtils.specialCharacters.containsKey(ch))
                {
                    throw new LexerError(generateErrorInfo(line, chNum),
                            "Illegal special character \\" + ch
                            + " in string \"" + str + "\"");
                }

                newStr += StringUtils.specialCharacters.get(ch);
                specChar = false;
            }
            else if (ch.equals('\\'))
            {
                specChar = true;
            }
            else
            {
                newStr += ch;
            }
        }

        if (specChar)
        {
            throw new LexerError(generateErrorInfo(line, chNum),
                    "Not completed special character in string \""
                    + str + "\"");
        }

        return newStr;
    }

    private static void printTokens(List<pl.rcebula.analysis.lexer.Token<?>> tokens)
    {
        for (pl.rcebula.analysis.lexer.Token<?> t : tokens)
        {
            System.out.println(t);
        }
    }

    private static List<pl.rcebula.analysis.lexer.Token<?>> generateCode(SimpleNode node)
    {
        return generateCode(node, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>());
    }

    private static List<pl.rcebula.analysis.lexer.Token<?>> generateCode(SimpleNode node, 
        List<pl.rcebula.analysis.lexer.Token<?>> prevTokens)
    {
        if (node.jjtGetNumChildren() == 0)
        {
            // je\u017celi nie null to znaczy, \u017ce node jest typu PRIM
			// ale nie jest FUN_CALL
            if (node.value != null)
            {
                return Arrays.asList((pl.rcebula.analysis.lexer.Token)node.value);
            }
            else
            {
                return prevTokens;
            }
        }
        else if (node.jjtGetNumChildren() == 1)
        {
            SimpleNode center = (SimpleNode)node.jjtGetChild(0);

            // FUN_CALL
            if (node.toString().equals("PRIM"))
            {
                // child jest typu FUN_CALL
                List<pl.rcebula.analysis.lexer.Token<?>> newTokens = 
                        new ArrayList<pl.rcebula.analysis.lexer.Token<?>>();
        
                newTokens.add((pl.rcebula.analysis.lexer.Token)node.value);
                newTokens.add(getOpenParToken());
                newTokens.addAll(generateCode(center, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>()));
                newTokens.add(getCloseParToken());

                return newTokens;
            }
            // COMMA
            else if (node.toString().equals("COMMA_EXPR"))
            {
                // child jest typu EXPR
                List<pl.rcebula.analysis.lexer.Token<?>> newTokens = 
                        new ArrayList<pl.rcebula.analysis.lexer.Token<?>>();
        
                newTokens.add(getCommaToken());
                newTokens.addAll(generateCode(center, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>()));

                return newTokens;
            }

            // expr bez comma_expr, fun_call nawiasy, primary nawiasy, neg_ex nic, not_ex nic, indx_ex nic
            if (node.value == null)
            {
                return generateCode(center, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>());
            }
            // neg_ex znak minus
            else if (node.value.equals("-"))
            {
                ValueErrorInfo vei = (ValueErrorInfo)node.value;
                pl.rcebula.analysis.lexer.Token funTok = getFunToken("NEGATE", vei.errorInfo);

                List<pl.rcebula.analysis.lexer.Token<?>> newTokens = 
                        new ArrayList<pl.rcebula.analysis.lexer.Token<?>>();
        
                newTokens.add(funTok);
                newTokens.add(getOpenParToken());
                newTokens.addAll(generateCode(center, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>()));
                newTokens.add(getCloseParToken());

                return newTokens;
            }
            // not_ex znak wykrzyknika
            else if (node.value.equals("!"))
            {
                ValueErrorInfo vei = (ValueErrorInfo)node.value;
                pl.rcebula.analysis.lexer.Token funTok = getFunToken("NOT", vei.errorInfo);

                List<pl.rcebula.analysis.lexer.Token<?>> newTokens = 
                        new ArrayList<pl.rcebula.analysis.lexer.Token<?>>();
        
                newTokens.add(funTok);
                newTokens.add(getOpenParToken());
                newTokens.addAll(generateCode(center, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>()));
                newTokens.add(getCloseParToken());

                return newTokens;
            }
            // neg_ex znak plus
            else if (node.value.equals("+"))
            {
                return generateCode(center, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>());
            }
            // pow_ex pot\u0119ga
            else if (node.value.equals("^"))
            {
                ValueErrorInfo vei = (ValueErrorInfo)node.value;
                pl.rcebula.analysis.lexer.Token funTok = getFunToken("POW", vei.errorInfo);

                List<pl.rcebula.analysis.lexer.Token<?>> newTokens = 
                        new ArrayList<pl.rcebula.analysis.lexer.Token<?>>();

                newTokens.add(funTok);
                newTokens.add(getOpenParToken());
                newTokens.addAll(prevTokens);
                newTokens.add(getCommaToken());
                newTokens.addAll(generateCode(center, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>()));
                newTokens.add(getCloseParToken());

                return newTokens;
            }
            // nieobs\u0142ugiwany znak
            else
            {
                throw new RuntimeException("Can't handle " + node.toString());
            }
        }
        else if (node.jjtGetNumChildren() == 2)
        {
            SimpleNode left = (SimpleNode)node.jjtGetChild(0);
            SimpleNode right = (SimpleNode)node.jjtGetChild(1);

            // EXPR, dzie\u0107mi s\u0105 OR_EX i COMMA_EXPR
            if (node.toString().equals("EXPR"))
            {
                List<pl.rcebula.analysis.lexer.Token<?>> newTokens = 
                        new ArrayList<pl.rcebula.analysis.lexer.Token<?>>();
        
                newTokens.addAll(generateCode(left, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>()));                
                newTokens.addAll(generateCode(right, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>()));

                return newTokens;
            }

            // je\u017celi nie ma warto\u015bci
            if (node.value == null)
            {
                return generateCode(right, generateCode(left, prevTokens));
            }
            else
            {
                pl.rcebula.analysis.lexer.Token funTok = null;
                // inaczej typu ValueErrorInfo, mo\u017cemy u\u017cy\u0107 metody equals(Object obj)
                if (node.value.equals("+"))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("ADD", vei.errorInfo);
                }
                else if (node.value.equals("-"))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("SUB", vei.errorInfo);
                }
                else if (node.value.equals("*"))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("MUL", vei.errorInfo);
                }
                else if (node.value.equals("/"))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("DIV", vei.errorInfo);
                }
                else if (node.value.equals("%"))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("MOD", vei.errorInfo);
                }
                else if (node.value.equals("||"))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("OR", vei.errorInfo);
                }
                else if (node.value.equals("&&"))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("AND", vei.errorInfo);
                }
                else if (node.value.equals("=="))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("EQ", vei.errorInfo);
                }
                else if (node.value.equals("!="))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("NEQ", vei.errorInfo);
                }
                else if (node.value.equals(">"))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("GT", vei.errorInfo);
                }
                else if (node.value.equals(">="))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("GE", vei.errorInfo);
                }
                else if (node.value.equals("<"))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("LS", vei.errorInfo);
                }
                else if (node.value.equals("<="))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("LE", vei.errorInfo);
                }
                else if (node.value.equals("[]"))
                {
                    ValueErrorInfo vei = (ValueErrorInfo)node.value;
                    funTok = getFunToken("GET", vei.errorInfo);
                }
                else
                {
                    throw new RuntimeException("Uknown node value: " + node.value.toString());
                }

                List<pl.rcebula.analysis.lexer.Token<?>> newTokens = 
                        new ArrayList<pl.rcebula.analysis.lexer.Token<?>>();

                newTokens.add(funTok);
                newTokens.add(getOpenParToken());
                newTokens.addAll(prevTokens);
                newTokens.add(getCommaToken());
                newTokens.addAll(generateCode(left, new ArrayList<pl.rcebula.analysis.lexer.Token<?>>()));
                newTokens.add(getCloseParToken());

                return generateCode(right, newTokens);
            }
        }
        else
        {
            throw new RuntimeException("Can't handle " + node.jjtGetNumChildren()
                + " node childrens");
        }
    }

    private static void traverse(SimpleNode node, String prefix)
    {
        if (node.jjtGetValue() != null)
        {
            System.out.println(node.toString(prefix) + ": " + node.jjtGetValue());
        }
        else
        {
            System.out.println(node.toString(prefix));
        }

        for (int i = 0; i < node.jjtGetNumChildren(); ++i)
        {
            SimpleNode n = (SimpleNode)node.jjtGetChild(i);
            traverse(n, prefix + "-");
        }
    }
}

class ValueErrorInfo
{
    public ValueErrorInfo(String value, ErrorInfo errorInfo)
    {
        this.value = value;
        this.errorInfo = errorInfo;
    }

    public boolean equals(Object obj)
    {
        String s = (String)obj;
        return value.equals(s);
    }

    public String value;
    public ErrorInfo errorInfo;
    
    @Override
    public String toString()
    {
        return value;
    }
}
PARSER_END(Parser)

SKIP : { "\n" | "\t" | " " }
SKIP : { < "@" (~["\n"])* > }

TOKEN : { < OR : "||" > }
TOKEN : { < AND : "&&" > }

TOKEN : { < EQ : "==" > }
TOKEN : { < NEQ : "!=" > }

TOKEN : { < LS : "<" > }
TOKEN : { < LE : "<=" > }
TOKEN : { < GT : ">" > }
TOKEN : { < GE : ">=" > }

TOKEN : { < PLUS : "+" > }
TOKEN : { < MINUS : "-" > }

TOKEN : { < TIMES : "*" > }
TOKEN : { < DIVIDE : "/" > }
TOKEN : { < MODULO : "%" > }

TOKEN : { < POWER: "^" > }

TOKEN : { < EXCL_MARK : "!" > }
TOKEN : { < COMMA : "," > }

TOKEN : { < OPEN_INDX : "[" > }
TOKEN : { < CLOSE_INDX : "]" > }

TOKEN : { < OPEN_PAR : "(" > }
TOKEN : { < CLOSE_PAR : ")" > }

TOKEN : { < KEYWORDS : "def" | "end" > }
TOKEN : { < NONE : "none" | "None" | "NONE" > }
TOKEN : { < TRUE : "true" | "True" | "TRUE" > }
TOKEN : { < FALSE : "false" | "False" | "FALSE" > }

TOKEN : { < INT : "0" | <DIGIT_NON_ZERO> (<DIGIT>)* > }
TOKEN : { < FLOAT : "0" <DOT> (<DIGIT>)+ | <DIGIT_NON_ZERO> (<DIGIT>)* <DOT> (<DIGIT>)+ > }

TOKEN : { < #DOT : "." > }
TOKEN : { < #DIGIT_NON_ZERO : ["1"-"9"] > }
TOKEN : { < #DIGIT : ["0"-"9"] > }

TOKEN : { < ID_STRUCT : <ID> (<DOT> <ID>)+ > }
TOKEN : { < ID : (<UTF_LETTER> | <UNDERLINE>) (<UTF_LETTER> | <UNDERLINE> | <DIGIT>)* > }

TOKEN : { < #UNDERLINE : ["_"] > }
TOKEN : { < #UTF_LETTER : [
"a"-"z", 
"A"-"Z", 
"\u00aa",
"\u00b5",
"\u00ba",
"\u00c0"-"\u00d6",
"\u00d8"-"\u00f6",
"\u00f8"-"\u02c1",
"\u02c6"-"\u02d1",
"\u02e0"-"\u02e4",
"\u02ec",
"\u02ee",
"\u0370"-"\u0374",
"\u0376",
"\u0377",
"\u037a"-"\u037d",
"\u037f",
"\u0386",
"\u0388"-"\u038a",
"\u038c",
"\u038e"-"\u03a1",
"\u03a3"-"\u03f5",
"\u03f7"-"\u0481",
"\u048a"-"\u052f",
"\u0531"-"\u0556",
"\u0559",
"\u0561"-"\u0587",
"\u05d0"-"\u05ea",
"\u05f0"-"\u05f2",
"\u0620"-"\u064a",
"\u066e",
"\u066f",
"\u0671"-"\u06d3",
"\u06d5",
"\u06e5",
"\u06e6",
"\u06ee",
"\u06ef",
"\u06fa"-"\u06fc",
"\u06ff",
"\u0710",
"\u0712"-"\u072f",
"\u074d"-"\u07a5",
"\u07b1",
"\u07ca"-"\u07ea",
"\u07f4",
"\u07f5",
"\u07fa",
"\u0800"-"\u0815",
"\u081a",
"\u0824",
"\u0828",
"\u0840"-"\u0858",
"\u08a0"-"\u08b2",
"\u0904"-"\u0939",
"\u093d",
"\u0950",
"\u0958"-"\u0961",
"\u0971"-"\u0980",
"\u0985"-"\u098c",
"\u098f",
"\u0990",
"\u0993"-"\u09a8",
"\u09aa"-"\u09b0",
"\u09b2",
"\u09b6"-"\u09b9",
"\u09bd",
"\u09ce",
"\u09dc",
"\u09dd",
"\u09df"-"\u09e1",
"\u09f0",
"\u09f1",
"\u0a05"-"\u0a0a",
"\u0a0f",
"\u0a10",
"\u0a13"-"\u0a28",
"\u0a2a"-"\u0a30",
"\u0a32",
"\u0a33",
"\u0a35",
"\u0a36",
"\u0a38",
"\u0a39",
"\u0a59"-"\u0a5c",
"\u0a5e",
"\u0a72"-"\u0a74",
"\u0a85"-"\u0a8d",
"\u0a8f"-"\u0a91",
"\u0a93"-"\u0aa8",
"\u0aaa"-"\u0ab0",
"\u0ab2",
"\u0ab3",
"\u0ab5"-"\u0ab9",
"\u0abd",
"\u0ad0",
"\u0ae0",
"\u0ae1",
"\u0b05"-"\u0b0c",
"\u0b0f",
"\u0b10",
"\u0b13"-"\u0b28",
"\u0b2a"-"\u0b30",
"\u0b32",
"\u0b33",
"\u0b35"-"\u0b39",
"\u0b3d",
"\u0b5c",
"\u0b5d",
"\u0b5f"-"\u0b61",
"\u0b71",
"\u0b83",
"\u0b85"-"\u0b8a",
"\u0b8e"-"\u0b90",
"\u0b92"-"\u0b95",
"\u0b99",
"\u0b9a",
"\u0b9c",
"\u0b9e",
"\u0b9f",
"\u0ba3",
"\u0ba4",
"\u0ba8"-"\u0baa",
"\u0bae"-"\u0bb9",
"\u0bd0",
"\u0c05"-"\u0c0c",
"\u0c0e"-"\u0c10",
"\u0c12"-"\u0c28",
"\u0c2a"-"\u0c39",
"\u0c3d",
"\u0c58",
"\u0c59",
"\u0c60",
"\u0c61",
"\u0c85"-"\u0c8c",
"\u0c8e"-"\u0c90",
"\u0c92"-"\u0ca8",
"\u0caa"-"\u0cb3",
"\u0cb5"-"\u0cb9",
"\u0cbd",
"\u0cde",
"\u0ce0",
"\u0ce1",
"\u0cf1",
"\u0cf2",
"\u0d05"-"\u0d0c",
"\u0d0e"-"\u0d10",
"\u0d12"-"\u0d3a",
"\u0d3d",
"\u0d4e",
"\u0d60",
"\u0d61",
"\u0d7a"-"\u0d7f",
"\u0d85"-"\u0d96",
"\u0d9a"-"\u0db1",
"\u0db3"-"\u0dbb",
"\u0dbd",
"\u0dc0"-"\u0dc6",
"\u0e01"-"\u0e30",
"\u0e32",
"\u0e33",
"\u0e40"-"\u0e46",
"\u0e81",
"\u0e82",
"\u0e84",
"\u0e87",
"\u0e88",
"\u0e8a",
"\u0e8d",
"\u0e94"-"\u0e97",
"\u0e99"-"\u0e9f",
"\u0ea1"-"\u0ea3",
"\u0ea5",
"\u0ea7",
"\u0eaa",
"\u0eab",
"\u0ead"-"\u0eb0",
"\u0eb2",
"\u0eb3",
"\u0ebd",
"\u0ec0"-"\u0ec4",
"\u0ec6",
"\u0edc"-"\u0edf",
"\u0f00",
"\u0f40"-"\u0f47",
"\u0f49"-"\u0f6c",
"\u0f88"-"\u0f8c",
"\u1000"-"\u102a",
"\u103f",
"\u1050"-"\u1055",
"\u105a"-"\u105d",
"\u1061",
"\u1065",
"\u1066",
"\u106e"-"\u1070",
"\u1075"-"\u1081",
"\u108e",
"\u10a0"-"\u10c5",
"\u10c7",
"\u10cd",
"\u10d0"-"\u10fa",
"\u10fc"-"\u1248",
"\u124a"-"\u124d",
"\u1250"-"\u1256",
"\u1258",
"\u125a"-"\u125d",
"\u1260"-"\u1288",
"\u128a"-"\u128d",
"\u1290"-"\u12b0",
"\u12b2"-"\u12b5",
"\u12b8"-"\u12be",
"\u12c0",
"\u12c2"-"\u12c5",
"\u12c8"-"\u12d6",
"\u12d8"-"\u1310",
"\u1312"-"\u1315",
"\u1318"-"\u135a",
"\u1380"-"\u138f",
"\u13a0"-"\u13f4",
"\u1401"-"\u166c",
"\u166f"-"\u167f",
"\u1681"-"\u169a",
"\u16a0"-"\u16ea",
"\u16f1"-"\u16f8",
"\u1700"-"\u170c",
"\u170e"-"\u1711",
"\u1720"-"\u1731",
"\u1740"-"\u1751",
"\u1760"-"\u176c",
"\u176e"-"\u1770",
"\u1780"-"\u17b3",
"\u17d7",
"\u17dc",
"\u1820"-"\u1877",
"\u1880"-"\u18a8",
"\u18aa",
"\u18b0"-"\u18f5",
"\u1900"-"\u191e",
"\u1950"-"\u196d",
"\u1970"-"\u1974",
"\u1980"-"\u19ab",
"\u19c1"-"\u19c7",
"\u1a00"-"\u1a16",
"\u1a20"-"\u1a54",
"\u1aa7",
"\u1b05"-"\u1b33",
"\u1b45"-"\u1b4b",
"\u1b83"-"\u1ba0",
"\u1bae",
"\u1baf",
"\u1bba"-"\u1be5",
"\u1c00"-"\u1c23",
"\u1c4d"-"\u1c4f",
"\u1c5a"-"\u1c7d",
"\u1ce9"-"\u1cec",
"\u1cee"-"\u1cf1",
"\u1cf5",
"\u1cf6",
"\u1d00"-"\u1dbf",
"\u1e00"-"\u1f15",
"\u1f18"-"\u1f1d",
"\u1f20"-"\u1f45",
"\u1f48"-"\u1f4d",
"\u1f50"-"\u1f57",
"\u1f59",
"\u1f5b",
"\u1f5d",
"\u1f5f"-"\u1f7d",
"\u1f80"-"\u1fb4",
"\u1fb6"-"\u1fbc",
"\u1fbe",
"\u1fc2"-"\u1fc4",
"\u1fc6"-"\u1fcc",
"\u1fd0"-"\u1fd3",
"\u1fd6"-"\u1fdb",
"\u1fe0"-"\u1fec",
"\u1ff2"-"\u1ff4",
"\u1ff6"-"\u1ffc",
"\u2071",
"\u207f",
"\u2090"-"\u209c",
"\u2102",
"\u2107",
"\u210a"-"\u2113",
"\u2115",
"\u2119"-"\u211d",
"\u2124",
"\u2126",
"\u2128",
"\u212a"-"\u212d",
"\u212f"-"\u2139",
"\u213c"-"\u213f",
"\u2145"-"\u2149",
"\u214e",
"\u2183",
"\u2184",
"\u2c00"-"\u2c2e",
"\u2c30"-"\u2c5e",
"\u2c60"-"\u2ce4",
"\u2ceb"-"\u2cee",
"\u2cf2",
"\u2cf3",
"\u2d00"-"\u2d25",
"\u2d27",
"\u2d2d",
"\u2d30"-"\u2d67",
"\u2d6f",
"\u2d80"-"\u2d96",
"\u2da0"-"\u2da6",
"\u2da8"-"\u2dae",
"\u2db0"-"\u2db6",
"\u2db8"-"\u2dbe",
"\u2dc0"-"\u2dc6",
"\u2dc8"-"\u2dce",
"\u2dd0"-"\u2dd6",
"\u2dd8"-"\u2dde",
"\u2e2f",
"\u3005",
"\u3006",
"\u3031"-"\u3035",
"\u303b",
"\u303c",
"\u3041"-"\u3096",
"\u309d"-"\u309f",
"\u30a1"-"\u30fa",
"\u30fc"-"\u30ff",
"\u3105"-"\u312d",
"\u3131"-"\u318e",
"\u31a0"-"\u31ba",
"\u31f0"-"\u31ff",
"\u3400"-"\u4db5",
"\u4e00"-"\u9fcc",
"\ua000"-"\ua48c",
"\ua4d0"-"\ua4fd",
"\ua500"-"\ua60c",
"\ua610"-"\ua61f",
"\ua62a",
"\ua62b",
"\ua640"-"\ua66e",
"\ua67f"-"\ua69d",
"\ua6a0"-"\ua6e5",
"\ua717"-"\ua71f",
"\ua722"-"\ua788",
"\ua78b"-"\ua78e",
"\ua790"-"\ua7ad",
"\ua7b0",
"\ua7b1",
"\ua7f7"-"\ua801",
"\ua803"-"\ua805",
"\ua807"-"\ua80a",
"\ua80c"-"\ua822",
"\ua840"-"\ua873",
"\ua882"-"\ua8b3",
"\ua8f2"-"\ua8f7",
"\ua8fb",
"\ua90a"-"\ua925",
"\ua930"-"\ua946",
"\ua960"-"\ua97c",
"\ua984"-"\ua9b2",
"\ua9cf",
"\ua9e0"-"\ua9e4",
"\ua9e6"-"\ua9ef",
"\ua9fa"-"\ua9fe",
"\uaa00"-"\uaa28",
"\uaa40"-"\uaa42",
"\uaa44"-"\uaa4b",
"\uaa60"-"\uaa76",
"\uaa7a",
"\uaa7e"-"\uaaaf",
"\uaab1",
"\uaab5",
"\uaab6",
"\uaab9"-"\uaabd",
"\uaac0",
"\uaac2",
"\uaadb"-"\uaadd",
"\uaae0"-"\uaaea",
"\uaaf2"-"\uaaf4",
"\uab01"-"\uab06",
"\uab09"-"\uab0e",
"\uab11"-"\uab16",
"\uab20"-"\uab26",
"\uab28"-"\uab2e",
"\uab30"-"\uab5a",
"\uab5c"-"\uab5f",
"\uab64",
"\uab65",
"\uabc0"-"\uabe2",
"\uac00"-"\ud7a3",
"\ud7b0"-"\ud7c6",
"\ud7cb"-"\ud7fb",
"\uf900"-"\ufa6d",
"\ufa70"-"\ufad9",
"\ufb00"-"\ufb06",
"\ufb13"-"\ufb17",
"\ufb1d",
"\ufb1f"-"\ufb28",
"\ufb2a"-"\ufb36",
"\ufb38"-"\ufb3c",
"\ufb3e",
"\ufb40",
"\ufb41",
"\ufb43",
"\ufb44",
"\ufb46"-"\ufbb1",
"\ufbd3"-"\ufd3d",
"\ufd50"-"\ufd8f",
"\ufd92"-"\ufdc7",
"\ufdf0"-"\ufdfb",
"\ufe70"-"\ufe74",
"\ufe76"-"\ufefc",
"\uff21"-"\uff3a",
"\uff41"-"\uff5a",
"\uff66"-"\uffbe",
"\uffc2"-"\uffc7",
"\uffca"-"\uffcf",
"\uffd2"-"\uffd7",
"\uffda"-"\uffdc"
] > }

TOKEN: {
<STRING: 
    "\"" 
    (
         "\\" ~[]     //any escaped character
    |                 //or
        ~["\"","\\"]  //any character except quote or backslash
    )* 
    "\"" > 
}

SimpleNode Start()        :
{/*@bgen(jjtree) START */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) START */
    try {
/*@egen*/
    Expression()
    <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Expression()       :
{/*@bgen(jjtree) EXPR */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) EXPR */
        try {
/*@egen*/
	or_ex()
	(
	    comma_expr()
	)?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void comma_expr()             :
{/*@bgen(jjtree) COMMA_EXPR */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMMA_EXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) COMMA_EXPR */
        try {
/*@egen*/
	<COMMA>
	Expression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void or_ex()        :
{/*@bgen(jjtree) OR_EX */
  SimpleNode jjtn000 = new SimpleNode(JJTOR_EX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) OR_EX */
    try {
/*@egen*/
    and_ex()
    or_ex_1()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void or_ex_1()          :
{/*@bgen(jjtree) OR_EX_1 */
    SimpleNode jjtn000 = new SimpleNode(JJTOR_EX_1);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) OR_EX_1 */
    try {
/*@egen*/
    (
        t = <OR>
        and_ex()
        or_ex_1()
        { 
            int newLine = t.beginLine + ei.getLineNum() - 1;
            int newCh;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("||", new ErrorInfo(newLine, newCh, ei.getFile()));
        }
    )?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void and_ex()         : 
{/*@bgen(jjtree) AND_EX */
  SimpleNode jjtn000 = new SimpleNode(JJTAND_EX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) AND_EX */
    try {
/*@egen*/
    eq_ex()
    and_ex_1()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void and_ex_1()           : 
{/*@bgen(jjtree) AND_EX_1 */
    SimpleNode jjtn000 = new SimpleNode(JJTAND_EX_1);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) AND_EX_1 */
    try {
/*@egen*/
    (
        t = <AND>
        eq_ex()
        and_ex_1()
        {
            int newLine = t.beginLine + ei.getLineNum() - 1;
            int newCh;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("&&", new ErrorInfo(newLine, newCh, ei.getFile()));
        }
    )?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void eq_ex()        : 
{/*@bgen(jjtree) EQ_EX */
  SimpleNode jjtn000 = new SimpleNode(JJTEQ_EX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) EQ_EX */
    try {
/*@egen*/
    cmp_ex()
    eq_ex_1()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void eq_ex_1()          : 
{/*@bgen(jjtree) EQ_EX_1 */
    SimpleNode jjtn000 = new SimpleNode(JJTEQ_EX_1);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) EQ_EX_1 */
    try {
/*@egen*/
    (
        t = <EQ>
        cmp_ex()
        eq_ex_1()
        {
            int newLine = t.beginLine + ei.getLineNum() - 1;
            int newCh;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("==", new ErrorInfo(newLine, newCh, ei.getFile()));
        }
    |
        t = <NEQ>
        cmp_ex()
        eq_ex_1()
        {
            newLine = t.beginLine + ei.getLineNum() - 1;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("!=", new ErrorInfo(newLine, newCh, ei.getFile()));
        }
    )?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void cmp_ex()         : 
{/*@bgen(jjtree) CMP_EX */
  SimpleNode jjtn000 = new SimpleNode(JJTCMP_EX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) CMP_EX */
    try {
/*@egen*/
    add_ex()
    cmp_ex_1()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void cmp_ex_1()           : 
{/*@bgen(jjtree) CMP_EX_1 */
    SimpleNode jjtn000 = new SimpleNode(JJTCMP_EX_1);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) CMP_EX_1 */
    try {
/*@egen*/
    (
        t = <LS>
        add_ex()
        cmp_ex_1()
        {
            int newLine = t.beginLine + ei.getLineNum() - 1;
            int newCh;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("<", new ErrorInfo(newLine, newCh, ei.getFile()));
        }
    |
        t = <LE>
        add_ex()
        cmp_ex_1()
        {
            newLine = t.beginLine + ei.getLineNum() - 1;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("<=", new ErrorInfo(newLine, newCh, ei.getFile()));
        }
    |
        t = <GT>
        add_ex()
        cmp_ex_1()
        {
            newLine = t.beginLine + ei.getLineNum() - 1;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo(">", new ErrorInfo(newLine, newCh, ei.getFile()));
        }
    |
        t = <GE>
        add_ex()
        cmp_ex_1()
        {
            newLine = t.beginLine + ei.getLineNum() - 1;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo(">=", new ErrorInfo(newLine, newCh, ei.getFile()));
        }
    )?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void add_ex()         : 
{/*@bgen(jjtree) ADD_EX */
  SimpleNode jjtn000 = new SimpleNode(JJTADD_EX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) ADD_EX */
    try {
/*@egen*/
    mul_ex()
    add_ex_1()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void add_ex_1()           : 
{/*@bgen(jjtree) ADD_EX_1 */
    SimpleNode jjtn000 = new SimpleNode(JJTADD_EX_1);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) ADD_EX_1 */
    try {
/*@egen*/
    (
        t = <PLUS>
        mul_ex()
        add_ex_1()
        {
            int newLine = t.beginLine + ei.getLineNum() - 1;
            int newCh;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("+", new ErrorInfo(newLine, newCh, ei.getFile()));
        }
    |
        t = <MINUS>
        mul_ex()
        add_ex_1()
        {
            newLine = t.beginLine + ei.getLineNum() - 1;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("-", new ErrorInfo(newLine, newCh, ei.getFile()));
        }
    )?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void mul_ex()         : 
{/*@bgen(jjtree) MUL_EX */
  SimpleNode jjtn000 = new SimpleNode(JJTMUL_EX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) MUL_EX */
    try {
/*@egen*/
    pow_ex()
    mul_ex_1()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void mul_ex_1()           : 
{/*@bgen(jjtree) MUL_EX_1 */
    SimpleNode jjtn000 = new SimpleNode(JJTMUL_EX_1);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) MUL_EX_1 */
    try {
/*@egen*/
    (
        t = <TIMES>
        pow_ex()
        mul_ex_1()
        {
            int newLine = t.beginLine + ei.getLineNum() - 1;
            int newCh;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("*", new ErrorInfo(newLine, newCh, ei.getFile()));
        }
    |
        t = <DIVIDE>
        pow_ex()
        mul_ex_1()
        {
            newLine = t.beginLine + ei.getLineNum() - 1;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("/", new ErrorInfo(newLine, newCh, ei.getFile()));
        }
    |
        t = <MODULO>
        pow_ex()
        mul_ex_1()
        {
            newLine = t.beginLine + ei.getLineNum() - 1;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("%", new ErrorInfo(newLine, newCh, ei.getFile()));
        }
    )?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void pow_ex()         :
{/*@bgen(jjtree) POW_EX */
  SimpleNode jjtn000 = new SimpleNode(JJTPOW_EX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) POW_EX */
    try {
/*@egen*/
    neg_ex()
    pow_ex_1()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void pow_ex_1()           :
{/*@bgen(jjtree) POW_EX_1 */
    SimpleNode jjtn000 = new SimpleNode(JJTPOW_EX_1);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) POW_EX_1 */
    try {
/*@egen*/
    (
        t = <POWER>
        pow_ex()
        {
            int newLine = t.beginLine + ei.getLineNum() - 1;
            int newCh;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("^", new ErrorInfo(newLine, newCh, ei.getFile()));
        }
    )?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void neg_ex()         :
{/*@bgen(jjtree) NEG_EX */
    SimpleNode jjtn000 = new SimpleNode(JJTNEG_EX);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) NEG_EX */
    try {
/*@egen*/
    t = <MINUS>
    neg_ex()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        int newLine = t.beginLine + ei.getLineNum() - 1;
        int newCh;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        jjtn000.value = new ValueErrorInfo("-", new ErrorInfo(newLine, newCh, ei.getFile()));
    }
|
    t = <PLUS>
    neg_ex()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        newLine = t.beginLine + ei.getLineNum() - 1;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        jjtn000.value = new ValueErrorInfo("+", new ErrorInfo(newLine, newCh, ei.getFile()));
    }
|
    not_ex()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void not_ex()         :
{/*@bgen(jjtree) NEG_EX */
    SimpleNode jjtn000 = new SimpleNode(JJTNEG_EX);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) NEG_EX */
    try {
/*@egen*/
    t = <EXCL_MARK>
    indx_ex()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        int newLine = t.beginLine + ei.getLineNum() - 1;
        int newCh;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        jjtn000.value = new ValueErrorInfo("!", new ErrorInfo(newLine, newCh, ei.getFile()));
    }
|
    indx_ex()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void indx_ex()          : 
{/*@bgen(jjtree) INDX_EX */
  SimpleNode jjtn000 = new SimpleNode(JJTINDX_EX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) INDX_EX */
    try {
/*@egen*/
    primary()
    indx_ex_1()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void indx_ex_1()            : 
{/*@bgen(jjtree) INDX_EX_1 */
    SimpleNode jjtn000 = new SimpleNode(JJTINDX_EX_1);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) INDX_EX_1 */
    try {
/*@egen*/
    (
        t = <OPEN_INDX>
        Expression()
        <CLOSE_INDX>
	indx_ex_1()
        {
            int newLine = t.beginLine + ei.getLineNum() - 1;
            int newCh;
            if (t.beginLine == 1)
            {
                newCh = t.beginColumn + ei.getChNum() - 1;
            }
            else
            {
                newCh = t.beginColumn;
            }
            jjtn000.value = new ValueErrorInfo("[]", new ErrorInfo(newLine, newCh, ei.getFile()));
        }
    )?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



void primary()       :
{/*@bgen(jjtree) PRIM */
    SimpleNode jjtn000 = new SimpleNode(JJTPRIM);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) PRIM */
    try {
/*@egen*/
    t = <INT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/ 
    { 
        int newLine = t.beginLine + ei.getLineNum() - 1;
        int newCh;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        try
        {
            jjtn000.value = 
                new pl.rcebula.analysis.lexer.Token(TokenType.INT, Integer.parseInt(t.image),
                    new ErrorInfo(newLine, newCh, ei.getFile()));
        }
        catch (NumberFormatException ex)
        {
            throw new MyNumberFormatException(t);
        }
    }
|
    t = <FLOAT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { 
        newLine = t.beginLine + ei.getLineNum() - 1;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        try
        {
            jjtn000.value = 
                new pl.rcebula.analysis.lexer.Token(TokenType.FLOAT, Float.parseFloat(t.image),
                    new ErrorInfo(newLine, newCh, ei.getFile()));
        }
        catch (NumberFormatException ex)
        {
            throw new MyNumberFormatException(t);
        }
    }
|
	t = <ID>
	(
		fun_call()
	)?/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        newLine = t.beginLine + ei.getLineNum() - 1;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        jjtn000.value = 
            new pl.rcebula.analysis.lexer.Token(TokenType.ID, t.image,
                new ErrorInfo(newLine, newCh, ei.getFile()));
    }
|
    t = <ID_STRUCT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        newLine = t.beginLine + ei.getLineNum() - 1;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        jjtn000.value = 
            new pl.rcebula.analysis.lexer.Token(TokenType.ID_STRUCT, t.image,
                new ErrorInfo(newLine, newCh, ei.getFile()));
    }
|
    t = <TRUE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        newLine = t.beginLine + ei.getLineNum() - 1;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        jjtn000.value = 
            new pl.rcebula.analysis.lexer.Token(TokenType.BOOL, true,
                new ErrorInfo(newLine, newCh, ei.getFile()));
    }
|
    t = <FALSE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        newLine = t.beginLine + ei.getLineNum() - 1;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        jjtn000.value = 
            new pl.rcebula.analysis.lexer.Token(TokenType.BOOL, false,
                new ErrorInfo(newLine, newCh, ei.getFile()));
    }
|
    t = <NONE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        newLine = t.beginLine + ei.getLineNum() - 1;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        jjtn000.value = 
            new pl.rcebula.analysis.lexer.Token(TokenType.NONE, null,
                new ErrorInfo(newLine, newCh, ei.getFile()));
    }
|
    t = <STRING>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        newLine = t.beginLine + ei.getLineNum() - 1;
        if (t.beginLine == 1)
        {
            newCh = t.beginColumn + ei.getChNum() - 1;
        }
        else
        {
            newCh = t.beginColumn;
        }
        String str = parseString(t.image, t.beginLine, t.beginColumn);
        jjtn000.value = 
            new pl.rcebula.analysis.lexer.Token<String>(TokenType.STRING, str,
                new ErrorInfo(newLine, newCh, ei.getFile()));
    }
|
    <OPEN_PAR>
    Expression()
    <CLOSE_PAR>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void fun_call()           :
{/*@bgen(jjtree) FUN_CALL */
  SimpleNode jjtn000 = new SimpleNode(JJTFUN_CALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) FUN_CALL */
        try {
/*@egen*/
	<OPEN_PAR>
	Expression()
	<CLOSE_PAR>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

