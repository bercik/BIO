#INCLUDE("list.biom")

def retListOfStringsStartsWithTest(el, obj)
   @ inicjalizacja pola list obiektu obj
   IF(NOT(HAS_FIELD(obj, list)), AS_LOC(obj.list, CREATE_LIST()))
   @ sprawdzamy czy zaczyna się od test, jeżeli tak to dodajemy do listy
   IF(STARTS_WITH(TO_LOWERCASE(el.val), "test"), APPEND_TO_LIST(obj.list, el.val))
   @ zwracamy listę
   RET(obj.list)
end

def callEachFunction(el, obj)
   AS_GLOB(bt_fun_name, el.val)
   PRINTLN(el.val)
   CALL_BY_NAME(el.val)
end

def printErrorsSummary(el, obj)
   IF(EQ(el.val, 0), RET(none))
   AS_LOC(msg, ADD(el.key, ": ", TO_STR(el.val)))
   PRINTLN(msg)
end

def onSTART()
   @ słownik przechowujący liczbę errorów dla każdej funkcji
   AS_GLOB(bt_errors_dict, CREATE_DICT())
   @ pobieramy tablicę nazw funkcji użytkownika
   AS_LOC(funNames, GET_USER_FUNCTIONS_NAMES())
   @ tworzymy listę z nazwami funkcji zaczynającymi się od test
   AS_LOC(list, FOREACH(funNames, retListOfStringsStartsWithTest))

   @ wywołujemy wszystkie funkcje
   FOREACH(GET_ARRAY_LIST(list), callEachFunction)

   @ wyświetlamy podsumowanie
   AS_LOC(errors_dict, GET_GLOB(bt_errors_dict))
   @ podliczamy ilość zer
   AS_LOC(zeros, COUNT_EL(errors_dict, 0))

   PRINTLN()
   PRINTLN("SUMMARY")
   PRINTLN("--------------")

   @ jeżeli ilość zer jest równa ilości funkcji to znaczy
   @ że żaden test nie zawiódł
   IF
   (
      EQ(zeros, SIZE_OF_LIST(list)),
      CALL
      (
         PRINTLN("All test passed without errors"),
         EXIT()
      )
   )

   PRINTLN("Some test passed with errors. Here is list of tests and number of errors:")
   FOREACH(errors_dict, printErrorsSummary)
end

def BT_ASSERT_TRUE(bval, msg=none)
   AS_LOC(funName, GET_GLOB(bt_fun_name))
   _init_errors_dict(funName)
   IF
   (
      NOT(bval),
      _error(funName, msg)
   )
end

def BT_ASSERT_FALSE(bval, msg=none)
   AS_LOC(funName, GET_GLOB(bt_fun_name))
   _init_errors_dict(funName)
   IF
   (
      bval,
      _error(funName, msg)
   )
end

def BT_ASSERT_EQ(actual, expected, msg=none)
   AS_LOC(funName, GET_GLOB(bt_fun_name))
   _init_errors_dict(funName)
   IF
   (
      NEQ(actual, expected),
      _error(funName, msg, expVal=expected, actVal=actual)
   )
end

def BT_ASSERT_NEQ(actual, expected, msg=none)
   AS_LOC(funName, GET_GLOB(bt_fun_name))
   _init_errors_dict(funName)
   IF
   (
      EQ(actual, expected),
      _error(funName, msg, expVal=expected, actVal=actual)
   )
end

def BT_ASSERT_ERROR(val, msg=none)
   AS_LOC(funName, GET_GLOB(bt_fun_name))
   _init_errors_dict(funName)
   IF
   (
      NOT(IS_ERROR(val)),
      _error(funName, msg)
   )
end

def _error(funName, msg, expVal=none, actVal=none)
   _add_error(funName)
   PRINT_NTH_LAST_STACK_TRACE(CREATE_ERROR("", none, none), 1)
   PRINT(" failed")
   IF
   (
      AND(NOT(IS_NONE(expVal)), NOT(IS_NONE(actVal))),
      PRINT(". Expected", expVal, "got", actVal)
   )
   IF(NOT(IS_NONE(msg)), PRINTLN(ADD(": \"", msg, "\"")), PRINTLN())
end

def _init_errors_dict(funName)
   @ przypisujemy globalny słownik do zmiennej lokalnej
   AS_LOC(dict, GET_GLOB(bt_errors_dict))
   @ jeżeli klucz funName nie jest ustawiony to ustawiamy na 0
   IF(NOT(CONTAINS_KEY(dict, funName)), SET(dict, funName, 0)) 
end

def _add_error(funName)
   @ przypisujemy globalny słownik do zmiennej lokalnej
   AS_LOC(dict, GET_GLOB(bt_errors_dict))
   @ dodajemy jeden do klucza funName
   SET(dict, funName, ADD(GET(dict, funName), 1))
end
